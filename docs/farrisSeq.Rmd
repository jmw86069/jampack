---
title: "Farris et al RNA-seq methods"
output:
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 4
    toc_float:
      collapsed: true
    theme: cerulean
    css: liao_style.css
    highlight: pygments
    df_print: kable
  word_document:
    fig_width: 6
    fig_height: 6
    fig_caption: true
always_allow_html: yes
---

```{r setup, include=FALSE}
## To render this page:
## In the farrisSeq folder run:
## rmarkdown::render("farrisSeq.Rmd", "html_document", knit_root_dir=getwd(), output_dir=getwd());

suppressPackageStartupMessages(library(knitr));
suppressPackageStartupMessages(library(kableExtra));
suppressPackageStartupMessages(library(dplyr));
suppressPackageStartupMessages(library(plotly));
suppressPackageStartupMessages(library(made4));
suppressPackageStartupMessages(library(matrixStats));
suppressPackageStartupMessages(library(ComplexHeatmap));
suppressPackageStartupMessages(library(SummarizedExperiment));

suppressPackageStartupMessages(library(ggplot2));
suppressPackageStartupMessages(library(ggrepel));

suppressPackageStartupMessages(library(jamba));
suppressPackageStartupMessages(library(jamma));
suppressPackageStartupMessages(library(colorjam));
suppressPackageStartupMessages(library(splicejam));
suppressPackageStartupMessages(library(farrisdata));
knitr::opts_chunk$set(cache=TRUE, autodep=TRUE);

options("kable_styling_position"="left",
  "kable_styling_full_width"=FALSE,
  "kable_styling_bootstrap_options"=c("striped",
    "hover",
    "condensed",
    "responsive")
);
colorSub <- c(
   CA1="orange",
   CA2="orangered3",
   CA3="dodgerblue",
   DG="purple",
   CB="grey75",
   DE="grey30",
   CA1_CB="orange1",
   CA1_DE="darkorange2",
   CA2_CB="orangered1",
   CA2_DE="orangered3",
   CA3_CB="dodgerblue1",
   CA3_DE="dodgerblue3",
   DG_CB="darkorchid1",
   DG_DE="darkorchid3",
   `TRUE`="skyblue",
   `FALSE`="indianred3");
colorSub <- rgb2col(col2rgb(colorSub, alpha=TRUE));
```

This document describes and demonstrates analysis methods used to analyze
mouse hippocampal subregion-specific transcriptome RNA-seq data
(Farris et al manuscript in preparation.)

Raw sequence read data is provided through GEO GSE116343, with RNA-seq
data available at GEO GSE116342. Data used for analysis in R is provided
through an R package `farrisdata`, installed in R with
`devtools::install_github("jmw86069/farrisdata")`.

## Description of Input Data

The input data for this analysis workflow
is derived from Salmon quantitation files, which were already imported and
assembled into relevant data matrices.


### Gene expression data

Salmon quantitation files were imported using the R Bioconductor
package `tximport`, summarized to the gene level, and stored in an
R object `farrisGeneSE`, which is available in the R data package
`farrisdata`, installed using
`devtools::install_github("jmw86069/farrisdata")`.

```{r load_gene_data}
## Load the gene data
farrisGeneSE;
```

#### farrisGeneSE SummarizedExperiment format

`farrisGeneSE` is a `SummarizedExperiment` object with this content:

* **assays** list containing the numeric matrix with gene rows,
sample columns, with log2 median-normalized counts. Each row is named
using a unique gene symbol derived from the Gencode GTF file. To
access the normalized Salmon pseudocounts:

```{r, eval=FALSE}
assays(farrisGeneSE)[["counts"]]
```

* **assays** also contains the raw Salmon pseudocounts
accessible, using this command: `assays(farrisGeneSE)[["raw_counts"]]`

* **rowData** data.frame with gene rows, using the gene symbol derived from
the Gencode GTF file. 
```{r, gene_table, dependson="load_gene_data"}
as.data.frame(head(rowData(farrisGeneSE), 10)) %>%
   mutate() %>%
   dplyr::select(probeID, geneSymbol, ends_with("_type"),
      contains("has")) %>%
   kable(escape=FALSE) %>%
   kable_styling()
```

* **colData** annotated data.frame with sample rows, describing the
mouse hippocampal **Region**, **CellType**, **Sample**, and **groupName**.
```{r, sample_table, echo=FALSE, dependson="load_gene_data"}
df2 <- kable_coloring(colData(farrisGeneSE),
      colorSub=colorSub,
      row_color_by="groupName",
      returnType="kable") %>%
   collapse_rows(columns=c(5), valign="middle") %>%
   row_spec(0, background="#DDDDDD")
df2;
```


* **metadata** list describing the experimental design and contrasts used
for statistical comparisons.
    * **design** numeric matrix describing the sample design, suitable
    for use directly by methods from the R Bioconductor `limma` package.
    * **contrasts** numeric matrix describing contrasts, suitable for
    use directly by `limma`.
    * **samples** vector of samples used.
    * **genes** vector of genes used.


### Transcript expression data

Salmon  quantitation files were imported using `tximport` as above,
maintaining individual isoform abundances, then stored in an R object
`farrisTxSE`, which is available in the R data package
`farrisdata`, installed using
`devtools::install_github("jmw86069/farrisdata")`.

```{r load_tx_data}
## Load the gene data
data(farrisTxSE);
```

#### farrisTxSE format

The `farrisTxSE` object is a named list with content similar to that
described above for gene data:

* **assays** list containing the numeric matrix with gene rows,
sample columns, with log2 median-normalized counts. Each row is named
using a unique gene symbol derived from the Gencode GTF file.
* **rowData** data.frame with gene rows, using the gene symbol derived from
the Gencode GTF file.
```{r, tx_table, dependson="load_tx_data"}
tx_df <- subset(as.data.frame(rowData(farrisTxSE)),
   geneSymbol %in% c("Gria1","Shank2","Ntrk2")) %>%
   dplyr::select(geneSymbol,
      transcript_id,
      ends_with("_type"),
      contains("has"),
      contains("tpm"));
tx_df <- mixedSortDF(tx_df,
   byCols=match(c("geneSymbol","TxDetectedByTPM"),
     colnames(tx_df))*c(1,-1));
colorSubGene <- c(colorSub,
   group2colors(unique(tx_df$geneSymbol),
      cRange=c(20,30),
      lRange=c(80,90)));
tx_df2 <- kable_coloring(tx_df,
      colorSub=colorSubGene,
      row_color_by="geneSymbol",
      verbose=FALSE,
      returnType="kable") %>%
   collapse_rows(columns=2, valign="middle") %>%
   row_spec(0, background="#DDDDDD")

tx_df2;
```

* **colData** annotated data.frame with sample rows, describing the
mouse hippocampal **Region**, **CellType**, **Sample**, and **groupName**.
This data is identical to the sample table shown for `farrisGeneSE` above.
* **metadata** list describing the experimental design and contrasts used
for statistical comparisons.
    * **design** numeric matrix describing the sample design, suitable
    for use directly by methods from the R Bioconductor `limma` package.
    * **contrasts** numeric matrix describing contrasts, suitable for
    use directly by `limma`.
    * **samples** vector of samples used.
    * **genes** vector of genes used.


## Related analysis parameters

### Sickle read trimming

We used sickle version 1.33 to trim paired-end reads, with parameters
`-q 20 -l 20` to filter reads with quality threshold 20, and requiring
reads at least 20 base length.

### Cutadapt adapter trimming

We used cutadapt version 1.8.1 with parameter `-m 20` and with standard
Illumina Truseq adapter sequence `AGATCGGAAGAGC`.

### STAR sequence alignment

We used STAR version 2.5.1b to align versus Gencode vM12 comprehensive GTF,
with the following parameters, based upon ENCODE recommended RNA-seq
parameters:

```
--outFilterType Normal
--outFilterMultimapNmax 20
--alignSJoverhangMin 8
--alignSJDBoverhangMin 1
--outFilterMismatchNmax 999
--alignIntronMin 20
--alignIntronMax 1000000
--alignMatesGapMax 1000000
--outSAMtype BAM SortedByCoordinate Unsorted
--outWigType bedGraph
--outWigStrand Stranded
--outWigNorm None
--outReadsUnmapped Fastx
--outMultimapperOrder Random
```

### Salmon quantitation

We used salmon version 0.9.1 for transcript quantitation, using
Gencode vM12 comprehensive GTF file, using a index with kmer size 31,
and the cutadapt adapter-trimmed reads, with seqBias, VBO, and gcBias
options enabled.


### featureCounts read counting

We used featureCounts version 1.5.1 to produce per-gene counts, using
Gencode vM12 transcripts flattened per gene.


## Gene expression analysis summary


### BGA plot

```{r bga_plot, dependson="load_gene_data"}
bgaExprs <- assays(farrisGeneSE)$counts;
bgaExprs[bgaExprs < 7] <- 7;
bgaExprsUse <- bgaExprs[rowMins(bgaExprs) < rowMaxs(bgaExprs),,drop=FALSE];
nrow(bgaExprsUse);

salmonBga1 <- bga(dataset=bgaExprsUse,
   classvec=nameVector(colData(farrisGeneSE)$groupName,
      colnames(farrisGeneSE)),
   type="coa");
```

```{r bga_plotly, dependson="bga_plot"}
salmonBga1ly <- bgaPlotly3d(salmonBga1,
   axes=c(1,2,3),
   colorSub=colorSub,
   useScaledCoords=FALSE,
   drawVectors="none",
   drawSampleLabels=FALSE,
   superGroups=gsub("_.+", "", salmonBga1$fac),
   ellipseType="none",
   sceneX=0, sceneY=1, sceneZ=1,
   verbose=FALSE);
salmonBga1ly;
```

### Comparison with CA1 published data by Nakayama, Ainsley, Cajigas

First we calculate group medians using gene expression data, to determine
the set of genes detected above an expression threshold of 128 pseudocounts
(log2 = 7).

```{r genes_detected_CA1, fig.height=9, fig.width=6, dependson="load_gene_data"}
farrisGeneGroupMedians <- rowGroupMeans(assays(farrisGeneSE)[["counts"]],
   groups=colData(farrisGeneSE)$groupName,
   useMedian=TRUE);

# Plot histogram of expression in CA1_CB and CA1_DE
plotPolygonDensity(farrisGeneGroupMedians[,c("CA1_CB","CA1_DE")],
   xlim=c(0,20),
   ylim=c(0,700),
   ablineV=7);

# Detected genes in CA1_CB and CA1_DE
CA1detected <- (farrisGeneGroupMedians[,"CA1_CB"] > 7 &
   farrisGeneGroupMedians[,"CA1_DE"] > 7);
CA1detCBandDE <- rownames(farrisGeneGroupMedians)[CA1detected];
length(CA1detCBandDE);
```

Next we load previously gene lists representing detected CA1 dendrite genes
from published studies from Nakayama et al, Ainsley et al, and
Cajigas et al. These genes are available in the `farrisdata` package,
as described above.

Produce a 4-way Venn diagram showing the overlapping genes from these
studies.

```{r venn_4_way, fig.height=8, fig.width=8, dependson="genes_detected_CA1"}
GeneListL <- list(
  Farris=CA1detCBandDE,
  Cajigas=CajigasGenes,
  Ainsley=AinsleyGenes,
  Nakayama=NakayamaGenes);
GeneListIM <- list2im(GeneListL);
vps <- limma::vennDiagram(GeneListIM,
   circle.col=rainbowJam(4));

vps2 <- venn(GeneListL,
   show.plot=FALSE);
## Retrieve specific overlaps like this:
vps2vennL <- attr(vps2, "intersections");
## vps2vennL[["Farris:Cajigas:Ainsley:Nakayama"]]
```

### Correlation Centered by Compartment, refers to Figure 2

#### Cell Body

Per-sample correlation, centered across all CB samples. First, we
use Salmon normalized pseudocounts, restricted to genes where at
least one group mean value is above log2(7), which is >= 128
normalized pseudocounts.

Then data is centered per **Compartment**, so that CellBody samples
are centered by subtracting the mean CellBody expression per gene,
and Dendrite samples are centered by subtracting the mean Dendrite
expression per gene. This step uses `centerGeneData()` with the
argument `centerGroups`.

Next we prepare a data.frame with color coding to show the
CellType and Compartment values.

```{r sample_corr_cb_prep, dependson=c("load_gene_data","genes_detected_CA1")}
## farrisGeneGroupMedians
## Pull out only cell body samples
iSamples <- colnames(farrisGeneSE);
iSamplesCB <- vigrep("CB", iSamples);
iSamplesDE <- vigrep("DE", iSamples);
#iSamplesGrp <- colnames(iMatrix7grp);
iSamplesGrp <- colnames(farrisGeneGroupMedians);
iSamplesGrpCB <- vigrep("CB", iSamplesGrp);
iSamplesGrpDE <- vigrep("DE", iSamplesGrp);

corrCutoff <- 7;
genesAboveCutoff <- (rowMaxs(farrisGeneGroupMedians) >= corrCutoff);
genesAboveCutoffCB <- (rowMaxs(farrisGeneGroupMedians[,iSamplesGrpCB]) >= corrCutoff);
genesAboveCutoffDE <- (rowMaxs(farrisGeneGroupMedians[,iSamplesGrpDE]) >= corrCutoff);
genesAboveCutoffBoth <- (genesAboveCutoffCB & genesAboveCutoffDE);

iMatrix7 <- assays(farrisGeneSE[genesAboveCutoff,])[["counts"]];
centerGroups <- gsub("^.+(DE|CB).+$",
   "\\1",
   iSamples);
iMatrix7ctr <- centerGeneData(iMatrix7,
   centerGroups=centerGroups);
iMatrix7ctrCor <- cor(iMatrix7ctr);


## Generate some color bars to annotate the heatmap
colDataColorsRepL <- as.data.frame(colData(farrisGeneSE)[,c("CellType","Compartment")]);
colDataColorsRep <- df2colorSub(colDataColorsRepL, colorSub=colorSub);
```

Heatmap using ComplexHeatmap:

```{r sample_corr_cb_CH, fig.height=8, fig.width=10, dependson="sample_corr_cb_prep"}
pheat_colors <- list(Compartment=colorSub[c("CB","DE")],
   CellType=colorSub[c("CA1","CA2","CA3","DG")]);
pheat_breaks <- warpAroundZero(seq(from=-1, to=1, length.out=51), lens=1);

cBR <- circlize::colorRamp2(breaks=pheat_breaks,
   col=getColorRamp("RdBu_r", n=51));

colHA <- HeatmapAnnotation(colDataColorsRepL[iSamplesCB,2:1],
   show_annotation_name=TRUE,
   col=pheat_colors);
rowA <- rowAnnotation(colDataColorsRepL[iSamplesCB,2:1],
   col=pheat_colors,
   show_annotation_name=TRUE,
   show_legend=FALSE);

corHM <- Heatmap(iMatrix7ctrCor[iSamplesCB,iSamplesCB],
   name="Correlation",
   clustering_method_columns="ward.D",
   clustering_method_rows="ward.D",
   column_dend_height=unit(20, "mm"),
   row_dend_width=unit(20, "mm"),
   top_annotation=colHA,
   col=cBR);
draw(rowA + corHM, row_dend_side="left");

```


#### Cell Body and Dendrite

Correlation showing CA2_CB correlates highest with CA2_DE,
etc. for each CellType.

```{r corr_by_compartment_prep, dependson=c("load_gene_data","genes_detected_CA1")}
## farrisGeneGroupMedians[genesAboveCutoff,]
iMatrix7grp <- farrisGeneGroupMedians[genesAboveCutoffCB,];
centerGroupsGrp <- gsub("^.*(DE|CB).*$",
   "\\1",
   iSamplesGrp);
## 31oct2018 using mean instead of median
iMatrix7grpCtr <- centerGeneData(iMatrix7grp,
   centerGroups=centerGroupsGrp,
   mean=TRUE);
iMatrix7grpCtrCor <- cor(iMatrix7grpCtr);

## Generate some color bars to annotate the heatmap
colDataColorsGrpL <- data.frame(rbindList(
   strsplit(nameVector(iSamplesGrp), "_")));
colnames(colDataColorsGrpL) <- c("CellType","Compartment");
colDataColorsGrp <- df2colorSub(colDataColorsGrpL,
  colorSub=colorSub);
```

Heatmap using ComplexHeatmap:

```{r corr_by_compartment_CB, fig.height=8, fig.width=10, dependson="corr_by_compartment_prep"}
colHA2 <- HeatmapAnnotation(colDataColorsGrpL[iSamplesGrp,2:1],
   show_annotation_name=TRUE,
   col=pheat_colors);
rowA2 <- rowAnnotation(colDataColorsGrpL[iSamplesGrp,2:1],
   col=pheat_colors,
   show_annotation_name=TRUE,
   show_legend=FALSE);

corHM2 <- Heatmap(iMatrix7grpCtrCor[iSamplesGrp,iSamplesGrp],
   name="Correlation",
   clustering_method_columns="ward.D",
   clustering_method_rows="ward.D",
   column_dend_height=unit(20, "mm"),
   row_dend_width=unit(20, "mm"),
   top_annotation=colHA2,
   col=cBR);
draw(rowA2 + corHM2, row_dend_side="left");
```

#### Splom plot, refers to Figure 2, and Supplemental Figure 3

Scatterplot showing the +1,+1 selection of genes, which
helps define the gene lists in the next section.

```{r splom_CA2, fig.height=8, fig.width=8, dependson="corr_by_compartment_prep"}
corCols <- c("CA2_DE","CA2_CB");
cutCB <- round(digits=3, log2(1.5));
cutDE <- round(digits=3, log2(1.5));
splomL <- lapply(nameVector(c("CA1","CA2","CA3","DG")), function(k) {
   corCols <- vigrep(k, colnames(iMatrix7grpCtr));
   df1 <- as.data.frame(iMatrix7grpCtr[,corCols]);
   CBhit <- (abs(df1[,1]) > cutCB) * sign(df1[,1]);
   DEhit <- (abs(df1[,2]) > cutCB) * sign(df1[,2]);
   CBhitN <- paste0(k, "_", "CBhit");
   DEhitN <- paste0(k, "_", "DEhit");
   df1[,CBhitN] <- CBhit;
   df1[,DEhitN] <- DEhit;
   df1[,"GeneName"] <- rownames(df1);
   df1;
});
#table(splomL[[1]][,3:4])
splomLsub <- lapply(splomL, function(iDF){
   subset(iDF, !iDF[,3] %in% 0 | !iDF[,4] %in% 0)
});

splomDF2 <- rbindList(lapply(splomLsub, function(iDF){
   iDF[,"CellType"] <- gsub("_.+", "", colnames(iDF)[1]);
   colnames(iDF) <- c("CB","DE","CBhit","DEhit","GeneName","CellType");
   iDF;
}));
#splomDF2[,"row"] <- ifelse(splomDF2$CellType %in% c("CA1","CA2"), "CA1", "CA3");
splomDF2[,"CBDEhit"] <- paste0(splomDF2$CBhit,":",splomDF2$DEhit);

## Color-code the splom points
ccColors <- nameVector(rep("grey", 8), unique(splomDF2$CBDEhit));
ccColors[c("1:1","-1:-1")] <- "orangered3";
ccColors[c("-1:1","1:-1")] <- "grey";

## Gene labels
GeneHighlight <- c("Plch2","Rgs14","Necab2","1700024P16Rik");
splomDF2$label <- ifelse(splomDF2$GeneName %in% GeneHighlight,
  splomDF2$GeneName, "");


splomDF2[,"CBmaxGroupMean"] <- rowMaxs(farrisGeneGroupMedians[splomDF2$GeneName,iSamplesGrpCB]);
splomDF2[,"DEmaxGroupMean"] <- rowMaxs(farrisGeneGroupMedians[splomDF2$GeneName,iSamplesGrpDE]);
splomDF2[,"CBdet7"] <- (splomDF2[,"CBmaxGroupMean"] > 7)+0;
splomDF2[,"DEdet7"] <- (splomDF2[,"DEmaxGroupMean"] > 7)+0;

gg2 <- ggplot(splomDF2,
      aes(x=CB, y=DE, color=CBDEhit, fill=CBDEhit, GeneName=GeneName)) +
   geom_point(shape=21, size=2) +
   geom_vline(xintercept=c(-1,1)*0.585,
      linetype="dashed", color="grey20") +
   geom_hline(yintercept=c(-1,1)*0.585, linetype="dashed", color="grey20") +
   facet_wrap(facets=~CellType) +
   theme_jam() +
   scale_fill_manual(values=ccColors) +
   scale_color_manual(values=makeColorDarker(ccColors)) +
   ggrepel::geom_label_repel(aes(label=label),
      force=8,
      fill="white") +
   theme(legend.position="none");
gg2;
```

Microarray correlation heatmap.

### Neuronal Gene Lists

(Description of the four gene/transcript lists)

```{r neuronal_gene_lists}
## anyGenes1 is the full set of all genes with abundance > 1
anyGenes1 <- rownames(farrisGeneGroupMedians)[rowMaxs(farrisGeneGroupMedians) > 1];

## Filtering rules for CB and DE
## corrCutoff is 7
corFilterRuleCB <- (rowMaxs(farrisGeneGroupMedians[,iSamplesGrpCB]) >= corrCutoff);
corFilterRuleDE <- (rowMaxs(farrisGeneGroupMedians[,iSamplesGrpDE]) >= corrCutoff);
corFilterRule <- (corFilterRuleCB);

DEgenes7 <- rownames(farrisGeneGroupMedians)[corFilterRuleDE];
CBgenes7 <- rownames(farrisGeneGroupMedians)[corFilterRuleCB];
DEgenes7nonCB7 <- setdiff(DEgenes7, CBgenes7); # non-pyramidal
CBgenes7nonDE7 <- setdiff(CBgenes7, DEgenes7); # "non-DE genes"
DEgenes7andCB7 <- intersect(DEgenes7, CBgenes7);   # "DE genes"

## Define neuro gene lists
geneListsAll <- list(anyGenes1=anyGenes1,
   DEandCB=DEgenes7andCB7, # detected
   CBonly=CBgenes7nonDE7,  # detected only CB, not detected DE
   `non-pyramidal`=DEgenes7nonCB7,
   `CB1andDE1`=unique(subset(splomDF2,
      CBDEhit %in% "1:1" &
      CBdet7 %in% c(1) &
      DEdet7 %in% c(1))$GeneName)
   );
#lengths(geneListsAll);
geneListsDF <- data.frame(GeneList=names(geneListsAll),
   GeneCount=format(lengths(geneListsAll), big.mark=",", trim=TRUE));
rownames(geneListsDF) <- NULL;
colorSubGeneLists <- nameVector(rainbowJam(length(geneListsAll)),
   names(geneListsAll));
geneListsDF2 <- kable_coloring(geneListsDF,
      colorSub=colorSubGeneLists,
      row_color_by="GeneList",
      returnType="kable") %>%
   row_spec(0, background="#DDDDDD")
geneListsDF2;

```


Heatmap per-gene.


### Differential gene expression using limma

In preparation.


## Transcript analysis summary

### Definition of detected transcripts

We refer to the function `defineDetectedTx()` in the `jampack` R package.
The function takes normalized counts, normalized TPM values, sample
group information, and several cutoff values:

* **cutoffTxPctMax=10** requires a transcript isoform to be at least
10% of the highest isoform present in the same sample.
* **cutoffTxExpr=32** requires a transcript isoform to have at least
32 normalized counts.
* **cutoffTxTPMExpr=2** requires a transcript isoform to have at least
a TPM value of 2.
* All of the above criteria must be met for an isoform to be considered
"detected."

```{r, detectedTxTPM}
#refreshFunctions("farrisSalmonWWS");
#detectedTxTPML <- try(defineDetectedTx(
detectedTxTPML <- defineDetectedTx(
   iMatrixTx=assays(farrisTxSE)[["counts"]],
   iMatrixTxTPM=assays(farrisTxSE)[["tpm"]],
   groups=colData(farrisTxSE)$groupName,
   cutoffTxPctMax=10,
   cutoffTxExpr=32,
   cutoffTxTPMExpr=2,
   tx2geneDF=renameColumn(rowData(farrisTxSE),
     from=c("geneSymbol","probeID"),
     to=c("gene_name","transcript_id")),
   useMedian=FALSE,
   verbose=FALSE);
detectedTx <- detectedTxTPML$detectedTx;
numDetectedTx <- length(detectedTx);
detectedGenes <- mixedSort(unique(rowData(farrisTxSE[detectedTx,])$geneSymbol));
numDetectedGenes <- length(detectedGenes);
```

The code above defined
**`r format(numDetectedTx, big.mark=",")` detected
transcripts** by the given criteria,
covering **`r format(numDetectedGenes, big.mark=",")` unique gene symbols**.


### Transcript type per gene list

e.g. protein_coding, etc.

First, as a point of organizing the transcript-gene associations,
we read the Gencode GTF file and produce a `data.frame` with the
transcript-gene data.

Note: This step downloads the Gencode GTF file for version vM12,
then extracts data from that file. Once the `data.frame` is extracted,
it is stored in a text file for re-use.

```{r, tx2geneDF}
vM12gtf <- "ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_mouse/release_M12/gencode.vM12.annotation.gtf.gz";
vM12gtfBase <- basename(vM12gtf);
if (!file.exists(vM12gtfBase)) {
   curl::curl_download(url=vM12gtf,
      destfile=vM12gtfBase);
}
tx2geneFile <- file.path(".", "vM12gtf.tx2geneDF.txt");
if (!file.exists(tx2geneFile)) {
   tx2geneDF <- makeTx2geneFromGtf(GTF=vM12gtfBase,
      verbose=FALSE);
   write.table(file=tx2geneFile,
      x=tx2geneDF,
      sep="\t",
      quote=FALSE,
      na="",
      col.names=TRUE,
      row.names=FALSE);
} else {
   tx2geneDF <- read.table(tx2geneFile,
      sep="\t",
      check.names=FALSE,
      as.is=TRUE,
      fill=TRUE,
      quote="\"",
      allowEscapes=FALSE,
      comment.char="",
      header=TRUE,
      stringsAsFactor=FALSE);
}

```

### Neuronal Transcript Lists

The code below creates transcript lists equivalent to the
Neuronal Gene Lists above. The main distinction is that
the filtering rules are applied to transcript-level data,
as opposed to gene-level summary data above.
While a gene may be present in one category, perhaps only a
subset of its transcript isoforms may be present in that category.
Similarly, individual isoforms from the same gene may be present in
multiple distinct neuronal categories.

The transcript-level subsets are used to produce the 3-prime UTR
and CAI plots in subsequent figures.

```{r, neuronal_tx_lists}
## First calculate per-transcript group expression values
farrisTxGroupMedians <- rowGroupMeans(assays(farrisTxSE)[["counts"]],
   groups=colData(farrisTxSE)$groupName,
   useMedian=TRUE);
farrisTxTPMGroupMedians <- rowGroupMeans(assays(farrisTxSE)[["tpm"]],
   groups=colData(farrisTxSE)$groupName,
   useMedian=TRUE);

## Define cutoffs using CB and DE samples
## "Any" uses permissive cutoffs:
## pseudocounts >= 5, TPM >= 1
## no requirement for isoforms to be a certain percent the max per gene
detectedTxTPManyL <- defineDetectedTx(
   iMatrixTx=assays(farrisTxSE[,iSamplesCB])[["counts"]],
   iMatrixTxTPM=assays(farrisTxSE[,iSamplesCB])[["tpm"]],
   groups=colData(farrisTxSE[,iSamplesCB])$groupName,
   cutoffTxPctMax=0,
   cutoffTxExpr=5,
   cutoffTxTPMExpr=1,
   tx2geneDF=renameColumn(rowData(farrisTxSE),
     from=c("geneSymbol","probeID"),
     to=c("gene_name","transcript_id")),
   useMedian=FALSE,
   verbose=FALSE);
## Define cutoffs using cell body (CB) samples
## Requires pseudocounts >= 32, TPM >= 2
## and isoforms must be >= 10 percent the max per gene
detectedTxCBTPML <- defineDetectedTx(
   iMatrixTx=assays(farrisTxSE[,iSamplesCB])[["counts"]],
   iMatrixTxTPM=assays(farrisTxSE[,iSamplesCB])[["tpm"]],
   groups=colData(farrisTxSE[,iSamplesCB])$groupName,
   cutoffTxPctMax=10,
   cutoffTxExpr=32,
   cutoffTxTPMExpr=2,
   tx2geneDF=renameColumn(rowData(farrisTxSE),
     from=c("geneSymbol","probeID"),
     to=c("gene_name","transcript_id")),
   useMedian=FALSE,
   verbose=FALSE);
detectedTxTPMCB <- detectedTxCBTPML$detectedTx;
## Define cutoffs using cell body (DE) samples
## Requires pseudocounts >= 32, TPM >= 2
## and isoforms must be >= 10 percent the max per gene
detectedTxDETPML <- defineDetectedTx(
   iMatrixTx=assays(farrisTxSE[,iSamplesDE])[["counts"]],
   iMatrixTxTPM=assays(farrisTxSE[,iSamplesDE])[["tpm"]],
   groups=colData(farrisTxSE[,iSamplesDE])$groupName,
   cutoffTxPctMax=10,
   cutoffTxExpr=32,
   cutoffTxTPMExpr=2,
   tx2geneDF=renameColumn(rowData(farrisTxSE),
     from=c("geneSymbol","probeID"),
     to=c("gene_name","transcript_id")),
   useMedian=FALSE,
   verbose=FALSE);
detectedTxTPMDE <- detectedTxDETPML$detectedTx;

## Center data within Compartment
farrisTxTPMGroupMediansCtr2 <- centerGeneData(farrisTxTPMGroupMedians,
   centerGroups=gsub("^.+_", "", colnames(farrisTxTPMGroupMedians)),
   mean=TRUE, showGroups=FALSE);


## anyTx1 is the full set of all transcripts with abundance > 1
anyTx1 <- rownames(farrisTxGroupMedians)[rowMaxs(farrisTxGroupMedians) > 1];

## Filtering rules for CB and DE
## corrCutoff is 7
corFilterRuleTxCB <- (rowMaxs(farrisTxGroupMedians[,iSamplesGrpCB]) >= corrCutoff);
corFilterRuleTxDE <- (rowMaxs(farrisTxGroupMedians[,iSamplesGrpDE]) >= corrCutoff);
corFilterRuleTx <- (corFilterRuleTxCB);

## Subsets of detected transcripts
DEtx7 <- rownames(farrisTxGroupMedians)[corFilterRuleTxDE];
CBtx7 <- rownames(farrisTxGroupMedians)[corFilterRuleTxCB];
DEtx7nonCB7 <- setdiff(DEtx7, CBtx7); # non-pyramidal
CBtx7nonDE7 <- setdiff(CBtx7, DEtx7); # "non-DE genes"
DEtx7andCB7 <- intersect(DEtx7, CBtx7);   # "DE genes"

## Plot based upon TPM or counts
splomTxL <- lapply(nameVector(c("CA1","CA2","CA3","DG")), function(k) {
   corCols <- vigrep(k, colnames(farrisTxTPMGroupMediansCtr2));
   #df1 <- as.data.frame(farrisTxTPMGroupMediansCtr2[corFilterRuleTx,corCols]);
   df1 <- as.data.frame(farrisTxTPMGroupMediansCtr2[detectedTxTPMCB,corCols]);
   CBhit <- (abs(df1[,1]) > cutCB) * sign(df1[,1]);
   DEhit <- (abs(df1[,2]) > cutCB) * sign(df1[,2]);
   CBhitN <- paste0(k, "_", "CBhit");
   DEhitN <- paste0(k, "_", "DEhit");
   df1[,CBhitN] <- CBhit;
   df1[,DEhitN] <- DEhit;
   df1[,"GeneName"] <- rownames(df1);
   df1;
});
## Remove entries with (0,0) no change in any condition
splomTxLsub <- lapply(splomTxL, function(iDF){
   subset(iDF, !iDF[,3] %in% 0 | !iDF[,4] %in% 0)
});
## Create a data.frame for ggplot
splomTxDF2 <- rbindList(lapply(splomTxLsub, function(iDF){
   iDF[,"CellType"] <- gsub("_.+", "", colnames(iDF)[1]);
   colnames(iDF) <- c("CB","DE","CBhit","DEhit","transcript_id","CellType");
   iDF;
}));
splomTxDF2[,"Gene"] <- tx2geneDF[match(splomTxDF2$transcript_id, tx2geneDF$transcript_id),"gene_name"];
splomTxDF2[,"CBDEhit"] <- paste0(splomTxDF2$CBhit,
   ":",
   splomTxDF2$DEhit);
## Add rowMaxs for CB and DE to farrisSplomDF2
splomTxDF2[,"CBmaxGroupMedian"] <- rowMaxs(farrisTxGroupMedians[splomTxDF2$transcript_id, iSamplesGrpCB]);
splomTxDF2[,"DEmaxGroupMedian"] <- rowMaxs(farrisTxGroupMedians[splomTxDF2$transcript_id, iSamplesGrpDE]);
splomTxDF2[,"CBdet7"] <- (splomTxDF2[,"CBmaxGroupMedian"] > corrCutoff)+0;
splomTxDF2[,"DEdet7"] <- (splomTxDF2[,"DEmaxGroupMedian"] > corrCutoff)+0;

## Add TPM detected columns
splomTxDF2[,"CBmaxGroupMedianTPM"] <- rowMaxs(farrisTxTPMGroupMedians[splomTxDF2$transcript_id, iSamplesGrpCB]);
splomTxDF2[,"DEmaxGroupMedianTPM"] <- rowMaxs(farrisTxTPMGroupMedians[splomTxDF2$transcript_id, iSamplesGrpDE]);
splomTxDF2[,"CBdetTPM"] <- (splomTxDF2$transcript_id %in% detectedTxTPMCB)+0;
splomTxDF2[,"DEdetTPM"] <- (splomTxDF2$transcript_id %in% detectedTxTPMDE)+0;


## Put it all together into tx lists
txListsAll <- list(anyGenes1=anyTx1,
   DEandCB=DEtx7andCB7, # detected
   CBonly=CBtx7nonDE7,  # detected only CB, not detected DE
   `non-pyramidal`=DEtx7nonCB7,
   `CB1andDE1`=unique(subset(splomTxDF2,
      CBDEhit %in% "1:1" &
      CBdet7 %in% c(1) & #DEdetTPM %in% c(0) &
      DEdet7 %in% c(1))$transcript_id)
   );

#########################################################
## Same logic as above, using TPM instead of pseudocounts
detectedTxTPMany <- detectedTxTPManyL$detectedTx;
detectedTxTPMCB <- detectedTxCBTPML$detectedTx;
detectedTxTPMDE <- detectedTxDETPML$detectedTx;
txListsAllTPM <- list(anyGenes1=detectedTxTPMany,
   DEandCB=intersect(detectedTxTPMCB, detectedTxTPMDE),
   CBonly=setdiff(detectedTxTPMCB, detectedTxTPMDE),
   `non-pyramidal`=setdiff(detectedTxTPMDE, detectedTxTPMCB),
   `CB1andDE1`=unique(subset(splomTxDF2,
      CBDEhit %in% "1:1" &
      CBdetTPM %in% c(1) &
      DEdetTPM %in% c(1))$transcript_id)
   );

```


### Properties of hippocampus dendritic RNAs, supplemental figure 7


#### supp7A Heatmap of high-confidence dendritic, cell body retained, and non-pyramidal RNA lists


```{r, heatmap_genelists345}
gl4 <- unlist(geneListsAll[c(3,4,5)]);
## Make a vector of gene list names, named by gene
gl4names <- nameVector(rep(names(geneListsAll[3:5]), lengths(geneListsAll[3:5])),
   unlist(gl4));
#length(gl4);    # 3474 total
iSamplesGrpO <- mixedSort(iSamplesGrp);
iM4 <- farrisGeneGroupMedians[gl4,iSamplesGrpO];

## Create color bar for the top of the heatmap
colHA3 <- HeatmapAnnotation(colDataColorsGrpL[iSamplesGrpO,2:1],
   show_annotation_name=TRUE,
   col=pheat_colors);
rowHA3 <- HeatmapAnnotation(which="row",
   df=data.frame(List=gl4names[rownames(iM4)]),
   col=list(List=colorSubGeneLists[names(geneListsAll)[3:5]]),
   width=unit(1, "cm") )
rowHM3 <- Heatmap(data.frame(List=gl4names[rownames(iM4)]),
   name="List",
   width=unit(1, "cm"),
   show_row_names=FALSE,
   col=colorSubGeneLists[names(geneListsAll)[3:5]],
   cell_fun=function(j, i, x, y, width, height, fill) {
       grid.text(sprintf("%.1f", mat[i, j]), x, y, gp = gpar(fontsize = 10))
   })

## Define color ramp
pheat_expr_breaks <- warpAroundZero(seq(from=-2, to=18, length.out=51),
   baseline=5,
   lens=4);
range(pheat_expr_breaks);
cBRexpr <- circlize::colorRamp2(breaks=pheat_expr_breaks,
   colors=colorRampPalette(tail(getColorRamp("RdBu_r", n=15), 13))(51));

## Create the heatmap
glHM <- Heatmap(iM4[,iSamplesGrpO],
   name="Gene List Heatmap",
   cluster_columns=FALSE,
   show_row_names=FALSE,
   clustering_method_rows="ward.D",
   column_dend_height=unit(20, "mm"),
   row_dend_width=unit(20, "mm"),
   top_annotation=colHA3,
   split=gl4names[rownames(iM4)],
   use_raster=TRUE,
   raster_device="CairoPNG",
   col=cBRexpr);
#draw(rowHA3 + glHM + rowHM3, row_dend_side="left");
draw(rowHA3 + glHM, row_dend_side="left");
if (1 == 2) {
   hm4grp <- heatmap.2(iM4,
      col=colorRampPalette(tail(getColorRamp("RdBu_r"), 13))(31),
      #colLensFactor=2,
      symkey=FALSE,
      symbreaks=FALSE,
      trace="none",
      #distMethod="correlation",
      #colorSub=nameVector(rainbowCat(5), names(geneListsAll)),
      #distMethod="maximum", hclustMethod="complete",
      #rowGroups=nameVector(list2df(geneListsAll[c(3,4,5)])[,1:2])[gl4use],
      #RowvCutreeK=4,
      Colv=FALSE,
      labRow=NA,
      useRaster=TRUE);
}

```


#### supp7B Percent breakdown of transcript type by transcript list

In preparation.


#### supp7C Violin plot of annotated 3'UTR lengths in each RNA list

We imported Gencode vM12 comprehensive GTF into R using
R Bioconductor GenomicFeatures package, with which we derived
3'UTR regions, using `GenomicFeatures::makeTxDbFromGFF()` and
`GenomicFeatures::threeUTRsByTranscript()`, respectively.

This step re-uses the Gencode GTF file downloaded above, then
converts it to a `"Txdb"` object, which is a SQLite relational database
format. This database is saved into a file so it can be recalled
without re-creating the file again.

```{r, gencode_vM12_gtf}
localDb <- file.path(".", "vM12gtf.txdb");
if (!file.exists(localDb)) {
   vM12txdb <- GenomicFeatures::makeTxDbFromGFF(vM12gtfBase);
   AnnotationDbi::saveDb(x=vM12txdb, file=localDb);
} else {
   vM12txdb <- AnnotationDbi::loadDb(file=localDb);
}
```

```{r, three_utr_length, dependson=c("gencode_vM12_gtf","tx2geneDF")}
## Check for valid vM12txdb since it is not cached properly by knitr
if (!DBI::dbIsValid(dbconn(vM12txdb))) {
   vM12txdb <- AnnotationDbi::loadDb(file=localDb);
}
## Grab three prime UTR into a GRangesList
gencode3utr <- GenomicFeatures::threeUTRsByTranscript(vM12txdb,
   use.names=TRUE);
values(gencode3utr@unlistData)[,"transcript_id"] <- rep(names(gencode3utr), lengths(gencode3utr));
values(gencode3utr@unlistData)[,"gene_id"] <- tx2geneDF[values(gencode3utr@unlistData)[,"transcript_id"],"gene_id"];
values(gencode3utr@unlistData)[,"gene_name"] <- tx2geneDF[values(gencode3utr@unlistData)[,"transcript_id"],"gene_name"];
values(gencode3utr@unlistData)[,"gene_type"] <- tx2geneDF[values(gencode3utr@unlistData)[,"transcript_id"],"gene_type"];
values(gencode3utr@unlistData)[,"transcript_type"] <- tx2geneDF[values(gencode3utr@unlistData)[,"transcript_id"],"transcript_type"];
names(gencode3utr@unlistData) <- pasteByRow(values(gencode3utr@unlistData)[,c("transcript_id","exon_rank")]);

## Summarize widths of three-prime-utr exons by transcript
threePrimeTx <- sum(width(gencode3utr));
GencodeVM12mm10threeUtrLength <- sum(width(gencode3utr));

## non-mito detectedTx
detectedTxMito <- subset(tx2geneDF[match(detectedTx, tx2geneDF$transcript_id),],
   grepl("^mt-", gene_name))$transcript_id;
detectedTxNonMito <- setdiff(detectedTx, detectedTxMito);

```


We plotted 3'UTR lengths as violin plots using only detected transcripts
based upon TPM criteria described elsewhere.

```{r, utr_length, fig.width=12, fig.height=10, dependson=c("three_utr_length")}
## Subset the txListsAll by those with three prime utr data
txLists3utr <- lapply(txListsAll, function(i){
   intersect(i, names(GencodeVM12mm10threeUtrLength));
});

## Pull pre-computed data from the farrisdata package
data(GencodeVM12mm10cai);
data(GencodeVM12mm10cdsLength);
data(GencodeVM12mm10caiCtLow);
data(GencodeVM12mm10caiCtBad);

## Create data in format for violin plots using ggplot2
violin3utrDF <- data.frame(check.names=FALSE,
   stringsAsFactors=FALSE,
   Tx=unlist(txLists3utr),
   gene_name=tx2geneDF[match(unlist(txLists3utr), tx2geneDF$transcript_id),"gene_name"],
   Subset=factor(rep(names(txLists3utr), lengths(txLists3utr)),
      levels=names(txLists3utr)),
   detectedTx=ifelse(unlist(txLists3utr) %in% detectedTxNonMito,
      "Detected Tx", "Undetected Tx"),
   threeUtrLength=GencodeVM12mm10threeUtrLength[unlist(txLists3utr)],
   txCai=GencodeVM12mm10cai[unlist(txLists3utr)],
   cdsLength=rmNA(naValue=0, GencodeVM12mm10cdsLength[unlist(txLists3utr)])
   );
## Now make a version that includes Tx counts in the labels
violin3utrDF$SubsetCount <- splicejam::factor2label(
   pasteByRowOrdered(violin3utrDF[,c("Subset","detectedTx")]),
   itemName="txs");
levels(violin3utrDF$SubsetCount) <- gsub("_([^(]+) Tx (.+) (txs)", " \\2 \\1 \\3",
   levels(violin3utrDF$SubsetCount))
colorSubGeneLists2 <- unlist(lapply(names(colorSubGeneLists), function(i){
   j <- vigrep(i, levels(violin3utrDF$SubsetCount));
   nameVector(rep(colorSubGeneLists[i], length(j)), j);
}));
## Note some tricky math, we take the median log length, then exponentiate
violin3utrDF$SubsetLabel <- splicejam::factor2label(
   pasteByRowOrdered(violin3utrDF[,c("Subset","detectedTx")]),
   types="count",
   aggFun=function(x,...){2^median(log2(x[x>10]),na.rm=TRUE)},
   valuesL=violin3utrDF[,"threeUtrLength",drop=FALSE],
   itemName="txs");
violin3utrDF$log3utr <- log10(1+violin3utrDF$threeUtrLength);

## Subset for specific neuronal groups
violin3utrDFsub <- subset(violin3utrDF, Subset %in% names(txListsAll)[c(3,4,5)]);

## 3 prime UTR length violin plots using ggplot2
gg3utr <- ggplot(data=subset(violin3utrDF, detectedTx %in% "Detected Tx"),
   aes(x=Subset, y=threeUtrLength)) +
   scale_y_continuous(trans="log10",
      breaks=c(10,20,50,100,200,300,500,750,1000,1500,2000,5000,10000,20000,50000),
      limits=10^c(1,4.35)) +
   #annotation_logticks(sides="lr") +
   facet_wrap(~detectedTx) +
   geom_violin(aes(fill=SubsetCount),
      scale="area",
      size=1,
      alpha=0.8,
      trim=TRUE,
      draw_quantiles=c(0.5)) +
   theme_jam(grid.minor.size=0) +
   scale_color_manual(values=colorSubGeneLists2) +
   scale_fill_manual(values=colorSubGeneLists2);
gg3utr;

```

##### Statistical tests comparing three prime UTR lengths

```{r, three_utr_stats}
## Wilcoxon t-test comparing the percent CAI
threeUtrCBonly <- subset(violin3utrDF, detectedTx %in% "Detected Tx" &
   Subset %in% "CBonly")$threeUtrLength;
threeUtrNonPyr <- subset(violin3utrDF, detectedTx %in% "Detected Tx" &
   Subset %in% "non-pyramidal")$threeUtrLength;
threeUtrCB1andDE1 <- subset(violin3utrDF, detectedTx %in% "Detected Tx" &
   Subset %in% "CB1andDE1")$threeUtrLength;

## parametric t-tests, using log10-transformed UTR lengths
t35utr <- t.test(log10(threeUtrCBonly), log10(threeUtrCB1andDE1));
t34utr <- t.test(log10(threeUtrCBonly), log10(threeUtrNonPyr));
t45utr <- t.test(log10(threeUtrNonPyr), log10(threeUtrCB1andDE1));

## Wilcoxon non-parametric t-tests
wt35utr <- wilcox.test(threeUtrCBonly, threeUtrCB1andDE1);
wt34utr <- wilcox.test(threeUtrCBonly, threeUtrNonPyr);
wt45utr <- wilcox.test(threeUtrNonPyr, threeUtrCB1andDE1);

TtestStatsUtr <- list(t35utr=t35utr,
   t34utr=t34utr,
   t45utr=t45utr,
   wt35utr=wt35utr,
   wt34utr=wt34utr,
   wt45utr=wt45utr);
TtestStatsUtrDF <- rbindList(lapply(names(TtestStatsUtr), function(t1){
   t <- TtestStatsUtr[[t1]];
   data.frame(data.name=t$data.name,
      p.value=t$p.value,
      method=t$method);
}));

## Print stats table
colorSubMethod <- group2colors(levels(TtestStatsUtrDF$method));
TtestStatsUtrDF$p.value <- format(TtestStatsUtrDF$p.value,
   digits=3,
   trim=TRUE);
TtestStatsUtrDF2 <- kable_coloring(TtestStatsUtrDF,
      colorSub=colorSubMethod,
      row_color_by="method",
      returnType="kable") %>%
   row_spec(0, background="#DDDDDD")
TtestStatsUtrDF2;

```


#### supp7D Proximal versus distal 3'UTR detected in each RNA list per compartment

In preparation.


#### supp7E Violin plot of the average percentage of codons with CAI <= 0.5 per RNA list

Codon CAI values are loaded via the `farrisdata` R package, and can be
calculated using methods described in the `jampack` R package suite.


```{r, codon_usage, fig.width=12, fig.height=10, dependson=c("three_utr_length")}
## codon adaptability index (cai) values are pre-computed and
## available from the farrisdata package
#data(GencodeVM12mm10cai);

## Subset transcript lists for entries having CAI data,
## which mostly filters for CDS-encoding Txs
txListsCai <- lapply(txListsAll, function(i){
   intersect(i, names(GencodeVM12mm10cai))
});
txListsCaiTPM <- lapply(txListsAllTPM, function(i){
   intersect(i, names(GencodeVM12mm10cai))
});
#txListsCai <- txListsCaiTPM;


## Create data in format for violin plots using ggplot2
violinCaiDF <- data.frame(check.names=FALSE,
   stringsAsFactors=FALSE,
   Tx=unlist(txListsCai),
   gene_name=tx2geneDF[match(unlist(txListsCai), tx2geneDF$transcript_id),"gene_name"],
   Subset=factor(rep(names(txListsCai), lengths(txListsCai)),
      levels=names(txListsCai)),
   detectedTx=ifelse(unlist(txListsCai) %in% detectedTxNonMito,
      "Detected Tx", "Undetected Tx"),
   txCai=GencodeVM12mm10cai[unlist(txListsCai)],
   cdsLength=GencodeVM12mm10cdsLength[unlist(txListsCai)],
   ctLowCai=GencodeVM12mm10caiCtLow[unlist(txListsCai)],
   pctLowCai=(GencodeVM12mm10caiCtLow[unlist(txListsCai)] /
         GencodeVM12mm10cdsLength[unlist(txListsCai)] *100),
   ctBadCai=GencodeVM12mm10caiCtBad[unlist(txListsCai)],
   pctBadCai=(GencodeVM12mm10caiCtBad[unlist(txListsCai)] /
         GencodeVM12mm10cdsLength[unlist(txListsCai)] *100),
   txCaiQ1=GencodeVM12mm10caiQ1mean[unlist(txListsCai)]
   );

## Now make a version that includes Tx counts in the labels
violinCaiDF$SubsetCount <- splicejam::factor2label(violinCaiDF$Subset,
   itemName="txs");
violinCaiDF$SubsetLabel <- splicejam::factor2label(violinCaiDF$Subset,
   types="count",
   aggFun=median,
   valuesL=violinCaiDF[,"pctLowCai",drop=FALSE],
   itemName="txs");
colorSubGeneLists3 <- unlist(lapply(names(colorSubGeneLists), function(i){
   j <- vigrep(i, c(
      levels(violinCaiDF$SubsetLabel),
      levels(violinCaiDF$SubsetCount)));
   nameVector(rep(colorSubGeneLists[i], length(j)), j);
}));

## Subset for specific neuronal groups
violinCaiDFsub <- subset(violinCaiDF, Subset %in% names(txListsAll)[c(3,4,5)]);

## CAI violin plots using ggplot2
ggPctLowCai <- ggplot(data=subset(violinCaiDFsub, detectedTx %in% "Detected Tx"),
   aes(x=Subset, y=pctLowCai)) +
   #aes(x=Subset, y=txCai)) +
   facet_wrap(~detectedTx) +
   geom_violin(aes(fill=SubsetLabel), scale="area",
   #geom_violin(aes(fill=SubsetCount), scale="area",
      alpha=0.8, trim=TRUE, draw_quantiles=c(0.5)) +
   ylim(c(0, 20)) +
   theme_jam(grid.minor.size=0) +
   scale_color_manual(values=colorSubGeneLists3) +
   scale_fill_manual(values=colorSubGeneLists3);
ggPctLowCai;

```

##### Statistical tests comparing gene lists

```{r, cai_stats}
## Wilcoxon t-test comparing the percent CAI
caiCBonly <- subset(violinCaiDFsub, detectedTx %in% "Detected Tx" &
   Subset %in% "CBonly")$pctLowCai;
caiNonPyr <- subset(violinCaiDFsub, detectedTx %in% "Detected Tx" &
   Subset %in% "non-pyramidal")$pctLowCai;
caiCB1andDE1 <- subset(violinCaiDFsub, detectedTx %in% "Detected Tx" &
   Subset %in% "CB1andDE1")$pctLowCai;

## parametric t-tests
t35cai <- t.test(caiCBonly, caiCB1andDE1);
t34cai <- t.test(caiCBonly, caiNonPyr);
t45cai <- t.test(caiNonPyr, caiCB1andDE1);

## Wilcoxon non-parametric t-tests
wt35cai <- wilcox.test(caiCBonly, caiCB1andDE1);
wt34cai <- wilcox.test(caiCBonly, caiNonPyr);
wt45cai <- wilcox.test(caiNonPyr, caiCB1andDE1);

TtestStatsCai <- list(t35cai=t35cai,
   t34cai=t34cai,
   t45cai=t45cai,
   wt35cai=wt35cai,
   wt34cai=wt34cai,
   wt45cai=wt45cai);
TtestStatsCaiDF <- rbindList(lapply(names(TtestStatsCai), function(t1){
   t <- TtestStatsCai[[t1]];
   data.frame(data.name=t$data.name,
      p.value=t$p.value,
      method=t$method);
}));

## Print stats table
colorSubMethod <- group2colors(levels(TtestStatsCaiDF$method));
#TtestStatsCaiDF$p.value <- sfsmisc::pretty10exp(TtestStatsCaiDF$p.value);
TtestStatsCaiDF$p.value <- format(TtestStatsCaiDF$p.value,
   digits=3,
   trim=TRUE);
TtestStatsCaiDF2 <- kable_coloring(TtestStatsCaiDF,
      colorSub=colorSubMethod,
      row_color_by="method",
      returnType="kable") %>%
   row_spec(0, background="#DDDDDD")
TtestStatsCaiDF2;

```


#### supp7F Heatmap of hypergeometric enrichment P-values of cell type by RNA list

In preparation.


### Differential transcript isoform analysis limma


### Splicing, Sashimi plots




## Gene Set Enrichment

### Selection of gene hits

Used DESeq-normalized expression values.


### Hypergeometric enrichment using MSigDB v6.0


#### Preparing MSigDB v6.0 data

Creating gmtT format, refreshing gene symbols in the gmtT data,
and the RNAseq gene hit data to be fully in sync.

Commentary on alt gene symbols, conversion to official mouse
Entrez gene symbols.


#### enrichSimple

Wrapper around standard hypergeometric enrichment tests, with
a custom background of detected genes.


### MultiEnrichMap

Subset pathways for top 15 per source-category

Heatmap of enrichment P-values.

Cnet plot


